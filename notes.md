**[Lesson #1]**
Делаем разметку интуитивно, пользуясь логикой, что большие теги в маленькие класть не надо, но помним, что это "правило" не панацея и нужно проверять вложенность тегов валидатором. А также ознакомиться с документацией: https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories

- <header> — верхняя часть сайта (часто повторяется на всех страницах);
- <footer> — нижняя часть сайта (часто повторяется на всех страницах);
- <main> — уникальная для каждой страницы контентная часть (внутри обязательно 1 <h1> с главной мыслью страницы (её описывающей));
- <aside> — боковая колонка (вне <main>);
- <nav> — сквозная навигация по сайту (обычно внутри <header> или сразу под ним);
- <section> — отдельная смысловая секция сайта, в которой всегда должен быть заголовок;
- <article> — похоже на <section>, но для более мелких элементов: товарные карточки, новости блога и т.д.
  // <article> - независимая единица, а <section> - составная часть чего-то. <section> может быть частью <article> и наоборот.

> Какие ориентиры у SEOшников?
> -> Ориентиры довольно таки расплывчаты, хотя Google сравнительно недавно выкатил Core Web Vitals, но помимо этого есть ещё:

- писать уникальный контент;
- загружать уникальные изображения;
- не покупать ссылки, натуральный прирост трафика (ссылки в соцсетях на сайт);

Следить за апдейтами можно в твиттере Google, например.

С точки зрения SEO, хорошо, когда <main> и <h1> идут как можно ближе к началу страницы. Поэтому, даже если визуально, например <aside> идёт перед <main>, то лучше его ставить на первое место в CSS, а в разметке после <main>.

На случай, если SEOшник нас попросит указать заголовок div'ом, чтобы поисковик на него не отвлекался, при этом внешний вид сайта не изменялся, то применяют следующий приём:
(см. ./screenshots/приём для SEO h1-h2-h3.jpg)

**[Lesson #3]**
Такие стили картинкам пишут обычно всегда, чтобы картинки не вылезали за пределы их родительских обёрток. А высота автоматическая, чтобы, если у нас ширина задана в разных местах, чтобы картинка не искажала свои пропорции.
<style>
	img {
		max-width: 100%;
		height: auto;
	}
</style>

Т.к. псевдоэлементы по умолчанию являются строчными, то если не прописан `display: inline-block;`, то треугольники будут выглядеть обрезанными. Также, если прописать то же свойство тексту и добавить им всем `vertical-align: middle;`, то они встанут ровно посередине.

Любой элемент при желании можно настроить с `word-break: break-word;` и тогда даже в середине слова его контента будет делаться перенос на др. строку. Так делают редко, но о такой возможности стоит помнить.

**Строчные элементы** Главное отличие их от блочных заключается в непременном сохранении своего положения в строке (margin не действует, а padding расширяет границы фона, но вторая строчка пойдёт, будто отступа не было). Также по ширине строчные берут ширину своего контента.
* При указании `vertical-align` элементам, его нужно ставить всем дочерним элементам внутри родителя (т.к. по умолчанию стоит baseline).

**Гибридное свойство inline-block** Подходит, когда нам нужно совместить свойства block & inline. Например в меню: (см. /html-lesson3-src/4-menu-in-line) Или для корректного отображения псевдо-элементов, т.к. мы не можем ограничить строчным width & height. 
* Помним также про то, что у строчно-блочных элементов, как и у строчных есть высота линии, поэтому может появляться отступ.
* Помним также, что в отличие от блочных, у них вертикальные margin суммируются (как впрочем и у других нестандартных видом элементов, например Flexbox).
* Также в HTML у строчных и строчно-блочных элементов есть т.н. "текстовая нода пробел", которая возникает между элементами всякий раз, когда в коде элемент записан на новой строке. Таким образом образуется раздражающее доп. расстояние. Это можно избежать либо поместив элементы друг за другом на одной строке, либо не закрывая теги <li>, как в примере на скриншоте: (см. inline-block ul_li removing spaces for horizontal line in menu.jpg). Это будет считаться валидной вёрсткой. 
Однако, есть более популярный вариант — это указать тегу <ul> `font-size: 0;`, а потом указать нормальный font-size тегу <li>.

>> ! Однако всё же чаще всего мы просто укажет `display: flex;` родителю и всё, т.к. `display: inline-block;` не даёт нам таких возможностей выравнивания и создаёт дополнительные ограничения.

> **Странное поведение блочных элементов** Вертикальный margin первого и последнего дочернего элемента контейнера вылезают за пределы контейнера. Решения: (см. how to fix a gap between blocks caused by vertical margin.jpg)

**[Lesson #4]**
Дмитрий Лаврик рекомендует использовать симметричные margin, вместо подхода "только margin-bottom", т.к. на его взгляд это более логично.
* Главное не забыть в адаптивной версии, при переходе на `display: block;` компенсировать схлопывание внешних отступов элементов.

<img> Атрибуты `width` и `height` работают как резервирование квадрата или прямоугольника определённых пропорций до загрузки картинки, на фактические размеры не влияет, т.ч. если в адаптиве будет в CSS прописано 200х200, а в атрибутах 300х300, то загрузится именное первое.

<!-- Весьма ответственное решение, т.к. такой подход может поломать какие-то стили других библиотек, ориентирующихся на другую модель. Быть с этим внимательными! -->
<style>
	* {
		box-sizing: border-box;
	}
</style>

> **Отрицательные отступы родителя** 
(см. /5-site-wrapper/)
Бывают часто блоки, где дочерние элементы стоят, например, плиткой с margin'ами, так вот крайние отступы этих элементов (например `margin: 5px;`) будут создавать 5 пикселей доп. отступа, что будет заставлять выглядеть контент этого блока расположенным не по линиям центрующего блока. Здесь нам пригодится приём отрицательных margin'ов для родительского контейнера (`margin: 0 -5px;`), таким образом он расширится ровно на 5px с каждой стороны, куда "провалятся" margin'ы дочерних элементов и контент встанет по направляющим линия контейнера.

**[Lesson #5]**
> *Про разницу `display: inline-block;` vs. `display: flex;`*
Конечно же, в большинстве случаев мы используем `display: flex;`, т.к. он на просто даёт больше возможностей и доставляет меньше хлопот, чем `display: inline-block;`, однако, чтобы установить например иконку рядом со ссылкой в элементе, которых может быть очень много или вложенные друг в друга в большом количестве могут начать съедать ресурсы и в отдельных случаях даже вызвать лаги на старых и медленных мобильных устройствах.

> **Width в % для aside** — используется крайне редко, т.к. боковая часть <aside> у нас остаётся узкой и как правило неизменяемой, в то время как контентная, куда более широкая нормально масштабируется. (Например часто в <aside> какой-то фильтр товаров или навигационное меню или похожий функционал.) Поэтому обычно контентная часть делается резиновой, а боковая фиксированной.