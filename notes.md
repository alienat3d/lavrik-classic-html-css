**[Lesson #1]**
Делаем разметку интуитивно, пользуясь логикой, что большие теги в маленькие класть не надо, но помним, что это "правило" не панацея и нужно проверять вложенность тегов валидатором. А также ознакомиться с документацией: https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories

- <header> — верхняя часть сайта (часто повторяется на всех страницах);
- <footer> — нижняя часть сайта (часто повторяется на всех страницах);
- <main> — уникальная для каждой страницы контентная часть (внутри обязательно 1 <h1> с главной мыслью страницы (её описывающей));
- <aside> — боковая колонка (вне <main>);
- <nav> — сквозная навигация по сайту (обычно внутри <header> или сразу под ним);
- <section> — отдельная смысловая секция сайта, в которой всегда должен быть заголовок;
- <article> — похоже на <section>, но для более мелких элементов: товарные карточки, новости блога и т.д.
  // <article> - независимая единица, а <section> - составная часть чего-то. <section> может быть частью <article> и наоборот.

> Какие ориентиры у SEOшников?
> -> Ориентиры довольно таки расплывчаты, хотя Google сравнительно недавно выкатил Core Web Vitals, но помимо этого есть ещё:

- писать уникальный контент;
- загружать уникальные изображения;
- не покупать ссылки, натуральный прирост трафика (ссылки в соцсетях на сайт);

Следить за апдейтами можно в твиттере Google, например.

С точки зрения SEO, хорошо, когда <main> и <h1> идут как можно ближе к началу страницы. Поэтому, даже если визуально, например <aside> идёт перед <main>, то лучше его ставить на первое место в CSS, а в разметке после <main>.

На случай, если SEOшник нас попросит указать заголовок div'ом, чтобы поисковик на него не отвлекался, при этом внешний вид сайта не изменялся, то применяют следующий приём:
(см. ./screenshots/приём для SEO h1-h2-h3.jpg)

**[Lesson #3]**
Такие стили картинкам пишут обычно всегда, чтобы картинки не вылезали за пределы их родительских обёрток. А высота автоматическая, чтобы, если у нас ширина задана в разных местах, чтобы картинка не искажала свои пропорции.
<style>
	img {
		max-width: 100%;
		height: auto;
	}
</style>

Т.к. псевдоэлементы по умолчанию являются строчными, то если не прописан `display: inline-block;`, то треугольники будут выглядеть обрезанными. Также, если прописать то же свойство тексту и добавить им всем `vertical-align: middle;`, то они встанут ровно посередине.

Любой элемент при желании можно настроить с `word-break: break-word;` и тогда даже в середине слова его контента будет делаться перенос на др. строку. Так делают редко, но о такой возможности стоит помнить.

**Строчные элементы** Главное отличие их от блочных заключается в непременном сохранении своего положения в строке (margin не действует, а padding расширяет границы фона, но вторая строчка пойдёт, будто отступа не было). Также по ширине строчные берут ширину своего контента.

**Гибридное свойство inline-block** Подходит, когда нам нужно совместить свойства block & inline. Например в меню: (см. /html-lesson3-src/4-menu-in-line) Или для корректного отображения псевдо-элементов, т.к. мы не можем ограничить строчным width & height. 
* Помним также про то, что у строчно-блочных элементов, как и у строчных есть высота линии, поэтому может появляться отступ.
* Помним также, что в отличие от блочных, у них вертикальные margin суммируются (как впрочем и у других нестандартных видом элементов, например Flexbox).
* Также в HTML у строчных и строчно-блочных элементов есть т.н. "текстовая нода пробел", которая возникает между элементами всякий раз, когда в коде элемент записан на новой строке. Таким образом образуется раздражающее доп. расстояние. Это можно избежать либо поместив элементы друг за другом на одной строке, либо не закрывая теги <li>, как в примере на скриншоте: (см. inline-block ul_li removing spaces for horizontal line in menu.jpg). Это будет считаться валидной вёрсткой. 
Однако, есть более популярный вариант — это указать тегу <ul> `font-size: 0;`, а потом указать нормальный font-size тегу <li>.

>> ! Однако всё же чаще всего мы просто укажет `display: flex;` родителю и всё, т.к. `display: inline-block;` не даёт нам таких возможностей выравнивания и создаёт дополнительные ограничения.

> **Странное поведение блочных элементов** Вертикальный margin первого и последнего дочернего элемента контейнера вылезают за пределы контейнера. Решения: (см. how to fix a gap between blocks caused by vertical margin.jpg)